# UIP-24: CTOR - Canonical Transactions Ordering

```
Author:  Andres Correa Casablanca <andres@thirdhash.com>
Status:  Draft
Created: 2018-12-14
```

## Abstract

Remove the current TTOR (Topological Transactions Ordering) implicit rule, and
impose a canonical transactions ordering on blocks (transactions ordered by
their IDs in lexicographical order).


## Motivation

Currently, when a proposer builds a block, or a relay node validates a block, it
has to take into account the transactions topological order. This has some
implications:

*   It imposes some overhead at the time of adding transactions to the block
    template (the best-known insertion algorithms for online topological
    ordering take `O(√m)` time, being `m` the number of possible edges)
    [[1][2]](#references).
*   Although it's possible to parallelize the validation with TTOR applying the
    OTI (outputs-then-inputs) algorithm by keeping track of the transactions
    indices [[3]](#references), the code becomes more complex and still requires
    an extra step to check that the TTOR rule is really applied (using OTI
    removes the previous implicit check).

However, using AOR (Any Ordering Rule) or CTOR can mitigate these two problems:

*   In the case of block creation, AOR would take `O(1)` time, while CTOR would
    need `O(log2(n))` time, therefore, they are able to scale better as the
    block size increases.
*   In the case of block validation, the OTI algorithm is trivial to implement
    without requiring to keep track of transaction indices nor any extra check.

It is also worth to say that in our case, with a target spacing (expected time
between blocks) of 16 seconds, the probability of having "0-conf" transactions
is even lower than in Bitcoin or Bitcoin Cash, so the topological ordering
property will hold with high probability at the intra-block level even if it's
not proactively enforced (which, in any case, is not a real advantage).

On top of this, CTOR eases the introduction of better block propagation
techniques, like Graphene [[4][7]](#references), and allows for compact
transaction inclusion/exclusion proofs applying algorithms to tackle the "set
reconciliation problem" [[5][6]](#references).


## Specification

*   All transactions in a block (except for the coinbase transaction, which must
    be the first one) MUST be in lexicographical order (using their ID as key).
    The order is relevant at the time of constructing the transactions Merkle
    tree.
*   The implementation MUST NOT rely on the topological order assumption in any
    of its steps.
*   Using the OTI algorithm is a good starting point, but not mandatory (other
    variants, like parallel algorithms, are possible).

## Rationale

Some developers argued against implementing CTOR by exposing that there was
still potential for optimization on top of TTOR, but no real alternative to
Graphene has been proposed, and it's not a good engineering practice to
prioritize micro-optimizations over picking good algorithms and/or data
structures.

Different ordering rules have been proposed, but they have some shortcomings:
*   AOR: Does not give us many of the  advantages that CTOR brings, like
    enabling the possibility of implementing Graphene.
*   GTOR (Gavin's Transactions Ordering): This is a complete canonical ordering
    within the set of topological orderings, but enforcing the extra constraint
    of lexicographical order for not directly related transactions. GTOR also
    enables the usage of mechanisms like Graphene, but it is more complex than
    simply using lexicographical order, and still has the overhead of having to
    preserve the topological order between transactions, without extra benefits.

Prior research work on the topic has been done by the Bitcoin Cash community
[[7][8]](#reference), and CTOR has been implemented at November 2018 as a hard
fork. Although Gavin first proposed a different canonical order, the final
Bitcoin Cash implementation followed the simpler lexicographical order).

### CTOR benefits and further enabled improvements

#### Intuition about how CTOR could help to decrease block propagation times

As users of Unit-e, we only care about which transactions belong or not belong
to a block, but not about its order (we think in terms of sets, not in terms of
lists), but a specific order is required to construct the Merkle tree that will
be used to build the header.

By not having to specify the transactions order (because it's implicit) at the
time of block propagation, we have to propagate less information. If we have `n`
transactions in a block (without considering the coinbase transaction), we have
`n!` different ways to sort them, so in the ideal case, encoding this
information would take `log2(n!)` bits (i.e., for 1000 transactions we need at
least 1.04KB, and 14.46KB for 10000).

As the block sizes increase over time, this insight gains importance.

#### CTOR enables Unit-e to use Graphene

The Graphene[[4]](#references) block propagation method (designed to decrease
block propagation times) relies on sending an invertible bloom lookup
table[[9]](#reference) and a
[Bloom filter](https://en.wikipedia.org/wiki/Bloom_filter) in order to specify
the block's transactions set.

These lightweight probabilistic data structures carry lossy-compressed
information about the transactions set, but don't provide any hint about its
order. We can obtain the order by different means:

*   Relying on a canonical order: In this case, there's no extra overhead.
*   Passing an explicit order: This would tamper Graphene's benefits as it
    would increase messages' sizes. As an example, for 2000 transactions,
    Graphene would need approximately `2.1KB`, adding the explicit order it
    would need `2.1KB + 2.3KB = 4.4KB`, more than doubling the message's size.
*   Hard-coding different ordering methods and specifying which one is being
    used: This option adds extra complexity and maintenance burden without
    providing known benefits.

Notice how AOR only allow us to apply the 2nd and 3rd option, while

## Backwards compatibility

We don't have to worry about backwards compatibility because Unit-e is still not
public at the time of writing this document.


## Reference implementation

Work in progress


## References

1.  [Practical performance of incremental topological sorting and cycle detection algorithms, 2016, Ragnar Lárus Sigurðsson](http://publications.lib.chalmers.se/records/fulltext/248308/248308.pdf)
2.  [Incremental Topological Sort and Cycle Detection in O(m sqrt(n)) Expected Total Time, Aaron Berstein, Shiri Chechik, January 2018](https://epubs.siam.org/doi/abs/10.1137/1.9781611975031.2)
3.  [Jonathan Toomin's proposal to apply OTI on top of TTOR](https://github.com/Bitcoin-ABC/bitcoin-abc/pull/244/files#diff-24efdb00bfbe56b140fb006b562cc70bR2222)
4.  [Graphene: A New Protocol for Block Propagation Using Set Reconciliation, 2017, A. Ozisik, G. Andresen, G. Bissias, A. Houmansadr, B. Levine](https://people.cs.umass.edu/~gbiss/graphene.pdf)
5.  [Set Reconciliation With Nearly Optimal Communication Complexity, 2000, Yaron Minsky, Ari Trachtenberg,IEEE, and Richard Zippe](https://pdfs.semanticscholar.org/be4e/60056b996b3df7ad71235aab133d304a38e3.pdf)
6.  [What’s the Difference? Efficient Set Reconciliation without Prior Contex, 2011, David Eppstein, Michael T. Goodrich, Frank Uyeda, George Varghese](https://www.ics.uci.edu/~eppstein/pubs/EppGooUye-SIGCOMM-11.pdf)
7.  [O(1) Block Propagation, Gavin Andresen](https://gist.github.com/gavinandresen/e20c3b5a1d4b97f79ac2)
8.  [Canonical Transaction Ordering for Bitcoin, 2018, Joannes Vermorel, Amaury Séchet, Shammah Chancellor, Tomas van der Wansem](https://blog.vermorel.com/pdf/canonical-tx-ordering-2018-06-12.pdf)
9.  [Invertible Bloom Lookup Tables, 2011, Michael T. Goodrich, Michael Mitzenmacher](https://arxiv.org/abs/1101.2245)


## Copyright

This document is dual-licensed under
[CC0](https://creativecommons.org/publicdomain/zero/1.0/) and
[MIT](https://opensource.org/licenses/MIT).
